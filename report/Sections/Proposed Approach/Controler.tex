The controller in our system need to be able to track an in a safely manner the optimal reference previosly planned. This need to be done in real-time, meaning a off-the-shelf algorithm will struggle, as show in~\cite{7400956}, since for a simpler problem computation time can range between the 1s to no even being able to compute a solution. To ensure we can maintain an optimal actuation whilest repecting the impose contraints of running in real time, a distributed NMPC using a realtime itteration as proposed in~\cite{diehl2002real} was used. 

Since the trajectory received from the planning phase already accounts for the kinodynamics of each robot, it provides a feasible reference for each robot to follow. Therefore, our control algorithm only needs to ensure safe tracking of this reference. To achieve this, we use a NMPC approach with soft constraints designed to prevent contact with any unknown objects. Like the previous phase, this stage operates in a distributed manner, meaning a consesus phase is also necessary in the optimization process, this is necessary due to lack of knowledge of the transported payload, since we do not have the inertia matrix, or even mass of the payload, the reference will 

After having the reference trajectory, we now need to be able to control each robot individually during the movement to be able to follow the reference in a safe manner, to do this, a NMPC with the dynamics we can see in equation~\ref{eq:Proposed approach: Controler: NMPC}, our system as we can see has both soft and hard constraint, this since the system parameters needed to be hard constraints, this way we make sure we have no problem with our simulation and control horizon having unfeasible states as this could be a problem. Our soft constraints will be used to make sure our system is safe, by not only penalizing the proximity to a know obstacle, but also to other robots in the grid, meaning some small deviation from the reference will be allowed.  By using a low order integration method we will not have as much precision as using a higher order integration model~\cite{gros2020linear}, but we will have faster computational time, allowing us to have a faster response time. A solution that was found by trial and error to have good results in combating the problem of the low order integration method, speacily for the quaternion representation in the state vector, was forcing the normalization of the quaternion after the integration step for all step in the horizon, this shown to not only have good results, but also having a faster computation time than a higher order method such as the Runge-Kutta method.



For us to be able to use our NMPC as our control allgorithm, we must be able to work with optimization times in the order of the low millisecond range, as as we can see in~\cite{7400956} off-the-shel algorithm need to be tuned and use some strategies in order to maintain these computation time, as they show, a problem can have solution time ranginng from bellow 1s, to 10s or not even finding a solution by simply changing the solver used in the optimization phase. Taking this into consideration, we real-time scheme was used in our control algorithm, first proposed by~\cite{diehl2002real}, this method perform only 1 SQP iteration per time step, and the calculation are divided between preparation step and feedback step. All operation that are not depended on the knowledge of the current state, are included in the preparation step, since the can be carried offline, reducing the load during the online step. After we have knowledge of the current state, the QP problem is construtdef and solved, giving us a $\Delta u$ and $\Delta x$. With this we can compute the control input as $u = u_{guess} + \Delta u$, and apply it immeasitly to the system, as per~\cite{diehl2005real}. We then need to maintain this control input being applied while we take care of the preparation step, where, as mention earlier, the solution of the previous time step is used as initial guess for the next itteration. By including the initial value embeding and the solving of the QP problem in the feedback problem, we can reduce the feedback time to only the computation time of the solver, as shown in~\cite{gros2020linear}
