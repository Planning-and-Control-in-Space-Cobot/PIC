First we can define our path planning problem, where multiple agents  $\mathcal{R} = \left\{ \mathcal{R}_1 \dots \mathcal{R}_N\right\}$, that move in a three-dimensional environment (3-D), $\mathcal{W}$ occupied by a set of know obstacles $\mathcal{O} = \left\{ O_{1}, \dots, O_{M} \right\}$. Each of the robots in the set from i=1, $\dots$, N has a configuration space $\mathcal{X}$, as well as a control input space defined by $\mathcal{U}$.

According to~\cite{lavalle2006planning}, a trajectory generation problem can be divided into three distinct subproblems: path planning, trajectory optimization, and velocity planning. In our system design, we use only two stages to generate a reference trajectory for the robots, yet we address all three subproblems by collapsing trajectory optimization and velocity planning into a single stage. 

The first stage takes as input the current configuration of the space and payload, along with the desired final configuration for the payload. It then outputs a rough path between these configurations. The second stage optimizes the trajectory by considering the system's dynamics and produces the reference trajectory for all robots in the system. To achieve this, only the initial configuration and the dynamics equations of all robots are required. 

Thanks to the feedback loop in the system, each stage can be rerun at any point without stopping the overall operation. This is particularly beneficial for adapting to changes in the environment not caused by our agents. This architecture does not disrupt the order of the system, as any changes made by a previous stage will propagate through to the final output.

\paragraph{Payload Path Planning} 
In this stage, a complete path is generated from the initial configuration to the final configuration, taking into account the current environment's disposition. The system dynamics are not considered at this stage. Given these parameters, we limit the algorithm to RRT* as presented in \ref{sec:Background:Trajectory Generation}, since it is the most efficient algorithm for this problem.

\paragraph{Robots Trajectory Planning and Optimization} 
In this stage, the trajectory generated in the previous stage is optimized by incorporating the system's dynamics. This stage can either produce a complete optimized path or optimize the path incrementally, as in the sliding window method, where only a portion of the path is optimized at each step. To implement a sliding window method, this stage must operate at a fixed rate rather than in an event-driven manner. This step ensures that the reference path passed to the controller is feasible. This optimization problem must be solved in a distributed way, since otherwise the system is not scalable as shown in~\cite{9429795} where the authors show the increase in computational time for only two robots in a path generation problem, where the computational time double in the case of a centralized approach, to solve this problem we can use an DNMPC, using the ADMM method to solve the optimization problem in a distributed way.

